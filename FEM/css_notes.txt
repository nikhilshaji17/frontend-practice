Just like the basic building block of html is the tag, 
the basic building block of CSS is the rule.

CSS is not a programming language, rather, it is a set of rules you give the browser.
CSS NEEDS HTML, but HTML can run independently.

We can write CSS inline (within the tag itself), we can write CSS in the <head></head> of our document, and we can write CSS
in a stylesheet and then import it to our project.

Example:
	h1 {
		color : red;
	}

h1 = selector. The browser looks for all tags of this 
	type and applies its respective style.

color = property.

red = value.

We need a semi-colon to denote the ending.

Parents and Children:
Example:	
	<div>
		<h1> Hello there </h1>
	</div>

div {
	color : blue
}

In the example above, the h1 tag also becomes blue.
	This is because the parent tag's color passes onto the 
	children.

NOTE: Not all styles get inherited. An example includes border-radius. 
	You will need to refer the documentation.
	Color and font permeate to the children.

A single property could have multiple values:
h1 {
	border: solid 3px black;
}

The above example is a shortcut way of writing:
h1 {
	border-style: solid;
	border-color: black;
	border-width: 3px;
}

To refer to a classname, use the . operator:
	.className {
		color : red;
		border : dashed;
	}

You can reuse styles across different tag types.

- Suppose you create two styles for the same selector, the one that's lower
	will take precedence, hence the "cascading" stylesheet:
- Example:
	.title {
		color : red;
	}

	.title {
		color : blue;
	}

- The title would be blue in color. 
- NOTE: The same does not apply for tag title. Classes are more specific,
	so even if you had a rule like the one below, the classes would take 
	preference.
	.title {
		color : red;
	}

	h1 {
		color : blue;
	}

In general, the more "specific" style takes precedence,
	if two styles have the same "specificity", then 
	the one lower takes precedence.

Example:

.brand .title {
	color : red;
}

.title {
	color : blue;
}

In the example above, although the .title below is blue,
	the selectors above it are more specific and hence,
	their styles take more precedence.

Example 2:

.brand .title {
	color : red;
}

.title .title{
	color : blue;
}

In the example above, although the same class name is provided 
	twice, CSS does not care, it treats it as 2 classes. 
	Since both have the same "specificity", the one below wins.

  .main-brand-2 {
    border: 1px solid black;
    color: red;
  }

  .title-2 {
    color: green;
  }

<h1 class="title-2 main-brand-2">Branding here</h1>

The text "Branding here" will be green in color, but it will have a border as well, since the border 
does not conflict with the .title-2 selector.
Keep in mind that each of these "conflicts" is resolved on a property-by-property basis.

NOTE: The space between the class names also matters:
Example: .title .main-brand {
	color : red;
}

.title.main-brand {
	color : blue;
}

The example without the space will look for a class with BOTH THE CLASS NAMES TOGETHER, IN ANY ORDER.
The example with the space will look for a class NAMED main-brand, which is nested within another class NAMED title.

ID's have the highest specificity.
Suppose you have:
	<h1 id="title" class="nav-head post-title">Hello there</h1>

#title {
	color : red;
}

.nav-head.post-title {
	color : blue;
}

The id at the top would have the highest priority. however, if you added something like:

#title.nav-head {
	color : pink;
}

This new style is more specific, hence our text would be pink.

The most priority is given to !important

So the order of priority would be:
!important -> inline styles -> #ids -> class_names -> tag names

Also, the order in which you import your stylesheets into the <head></head> tag also matters, this decides the order
of the cascade.

Pseudoclasses:
These allow you to add certain functionality, on if a situation is true.

Example:

.special-box {
	width: 200px;
	height: 200px;
	background-color: red;
}

.special-box:hover {
	width: 100px;
	height: 100px;
	background-color: green;
}

By default, the box would be 200px x 200px and red in color.
However, if you hover over it, then it would take on the properties below.

Another important pseudoclass would be :required and :optional (while filling up forms)
.list-items:nth-child(3) {
	color : red;
	font-style : bold;
}

.list-items:nth-child(2n) {
	...
}

This would apply a formula, where the 2nd, 4th and so on  elements would end up being modified.

NOTE: Certain pseudoclasses wouldn't work on mobile, like hover. Keep in mind.

Pseudoelement:
While pseudoclasses are represented by :, pseudoelements are represented by ::
These allow us to create text, image, symbols or other elements, without having to create new HTML elements.

Example:
<div class="chapter">This is a chapter of my book.</div>
<div class="chapter">This is a second chapter of my book.</div>

<style>
  .chapter {
    margin: 0;
  }
  .chapter::before {
    content: "‚ù¶";
    font-size: 50px;
    text-align: center;
    display: block;
  }
  
   .chapter::after {
    content: "‚ù¶";
    font-size: 50px;
    text-align: center;
    display: block;
  }
</style>

Layout:
Everything in CSS has a display property, whether explicit or not.
By default, <divs></divs> have display: block (they take an entire row). Every span has display : inline, and text is usually black
inherently.

block : takes the whole line to itself, thus allowing you to control borders, width, height etc.
inline : flows into the text, so it is controlled by the browser. We cannot adjust height, width etc.
inline-block : flows into the text, but we can control the width and height.

margin : pushes things away from it.
padding : pushes the things within it.

Note: height cannot be done in percentages, width can. Height can be modified in pixels however.

* {
	box-sizing : border-box;
}

Use above as the first line in all your code.
margin -> border -> padding -> content

float : The idea behind float is you'll tell an element to push itself as far left or right as possible, 
	and once it's out of space, go to the next line.

Certain properties are inherited from the parent by the children, these are usually font and text related properties. 
Many properties however, are not inherited by the children.

Flex:

flex : use this on the parent container, and the children will inherit it.

float = wraps
flex = squishes

Flex-container = set this on the parent
flex-items = set this on the children

justify-content worries about horizontal justification and align-items worries about vertical alignment.

Grid:
row-gap and column-gap are how you do gutters in grid i.e. the space between items in the grid

grid-template-column allows you to set up how the grid is constructed. You can do it in percentages, pixels, or fr which stands for fractions.

You can describe your grid as follows:

<style>
  .my-page-header {
    grid-area: nav-header;
    background-color: red;
    padding: 10px;
  }
  .my-page-body {
    grid-area: main-body;
    background-color: blue;
    padding: 10px;
  }

  .my-page-sidebar {
    grid-area: nav-side;
    background-color: green;
    padding: 10px;
  }

  .my-page-footer {
    grid-area: footer;
    background-color: yellow;
    padding: 10px;
  }

  .my-page {
    display: grid;
    grid-template-areas:
      "nav-header  nav-header  nav-header  nav-side"
      "main-body   main-body   .   		   nav-side"
      "footer      footer      footer      footer";
  }
</style>
<div class="my-page">
  <header class="my-page-header">the header</header>
  <div class="my-page-body">the body</div>
  <div class="my-page-sidebar">the sidebar</div>
  <footer class="my-page-footer">the footer</footer>
</div>

If you notice grid-template-areas, you see that you can describe your page layout in simple English terms.

Grid = For simple page layouts.
Flex = For unique, in depth layouts.

Animations:
We use the @keyframes keyword to define a set of instructions like rotate.

Example: 
<style>
  @keyframes spin {
    to { // This means transform to.
      transform: rotate(360deg);
    }
  }
  .spinny-boi {
    animation: spin 5s infinite linear; // This property allows you to use the previously defined animation.
    display: inline-block;
    font-size: 50px;
  }
</style>
<div class="spinny-boi">ü§¢</div>

position: relative make all the elements in a particular container move around relative to that container, not relative to 
  the entire page.
